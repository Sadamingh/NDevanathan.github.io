#ifndef INTERRUPTS_H
#define INTERRUPTS_H

#include <stdbool.h>

/*
 * Module to configure interrupts for Raspberry Pi.
 *
 * Author: Philip Levis <pal@cs.stanford.edu>
 * Author: Pat Hanrahan <hanrahan@cs.stanford.edu>
 * Author: Julie Zelenski <zelenski@cs.stanford.edu>
 *
 * Last update:   May 2020
 */

/*
 * `interrupts_init`
 *
 * Initialize interrupts. The init function must be called once
 * before any calls to other functions in the interrupts module.
 * The init function configures interrupts to a clean state.
 *
 *    - vector table is copied to destination address 0
 *    - all interrupt sources are off
 *    - interrupts are globally disabled
 *
 * Note that this function does _not_ deregister existing handlers.
 * This is so that if an interrupting-using module calls
 * `interrupts_init` then installs a handler, a subsequent
 * `interrupts_init` by another, unrelated module will not erase
 * the first one's handler. Without setting up more specific
 * initialization semantics and structure, this is the safe
 * approach to take that will save you from trying to debug for
 * hours why suddenly a module isn't receiving interrupts.
 */
void interrupts_init(void);

/*
 * `interrupts_global_enable`
 *
 * Turns on interrupts system-wide. Interrupts for events on sources
 * with registered handlers will call those handlers.
 */
void interrupts_global_enable(void);

/*
 * `interrupts_global_disable`
 *
 * Turns off all interrupts system-wide. No interrupts will be generated.
 * Does not remove/disable registered handlers/sources, just temporarily
 * suspends interrupt generation. Use `interrupts_global_enable` to
 * resume generating interrupts.
 */
void interrupts_global_disable(void);

/*
 * `interrupts_is_pending`
 *
 * Returns true if there is a pending event for the given source, false
 * otherwise. The source should be a value from the INTERRUPTS enum
 * below.
 */
bool interrupts_is_pending(unsigned int source);

/*
 * `interrupts_enable_source``
 *
 * Enable a particular interrupt source. The source itself must still
 * be configured to generate interrupts (and global interrupts must be
 * enabled) for a registered handler to be called. The source should be
 * a value from the INTERRUPTS enum below.
 */
bool interrupts_enable_source(unsigned int source);

/*
 * `interrupts_disable_source`
 *
 * Disable a particular interrpt source. Interrupts for this source
 * will not trigger a handler and will remain pending (until cleared).
 * The source should be a value from the INTERRUPTS enum below.
 */
bool interrupts_disable_source(unsigned int source);

/*
 * This typedef gives a nickname to the type of function pointer used as
 * a handler callback. A handler is registered to an interrupt source. When
 * an interrupt is generated by that source, the handler is called to
 * process it. A handler takes one argument of type unsigned int
 * (value of interrupted pc) and returns a bool, which indicates whether
 * the interrupt was successfully processed.
 */
typedef bool (*handler_fn_t)(unsigned int);

/*
 * `interrupts_register_handler`
 *
 * Install the handler function for a given interrupt source. Each interrupt
 * source can have one handler: further dispatch should be invoked by
 * the handler itself.
 *
 * Asserts if failed to install handler (i.e. vector table not properly
 * initialized or specified interrupt is invalid). Returns the old
 * handler that existed (NULL if none was). Valid interrupts are
 * basic interrupts and those with entries in the interrupt table in
 * the BCM2835 manual: GPU and other reserved interrupts are invalid.
 *
 * An interrupt source is identified by number. Valid source numbers are
 * listed below in the `interrupt_source` enumeration.
 * The sources we will commonly use are
 *     INTERRUPTS_GPIO3 for gpio interrupts (source shared by all gpios)
 *     INTERRUPTS_BASIC_ARM_TIMER_IRQ  for armtimer interrupts
 *
 * Note that calling this function does _not_ enable the interrupt!
 * you need to do that separately.
 */
handler_fn_t interrupts_register_handler(unsigned int source, handler_fn_t fn);

/* The valid interrupt sources that this module can enable, disable,
 * and handle. AUX through VC_UART are all IRQs from peripherals. There
 * are 64 peripheral interrupts, but only these ones should be handled by
 * your code -- the datasheet says (BCM2835 Sec 7.5)
 *    "The table has many empty entries. These should not be
 *     enabled as they will interfere with the GPU operation."
 *
 * So there is a peripheral interrupt 0 but you should not handle it.
 *
 * Values with _BASIC_ in them are basic interrupts that are generated
 * from the core itself. Normally, these are a completely separate
 * identifier space of interrupts. Basic interrupt 0 is the ARM_TIMER
 * interrupt, for example. Rather than have two separate sets of functions
 * for peripheral and basic interrupts, we just give them IDs > 64 and
 * then map them to their real values in the code. Using a single
 * identifier space means that we avoid the inevitable bug of someone
 * passing a basic interrupt ID to a peripheral interrupt function and
 * vice versa.
 */
enum interrupt_source {
    INTERRUPTS_SHARED_START    = 29,
    INTERRUPTS_AUX             = 29,
    INTERRUPTS_I2CSPISLV       = 43,
    INTERRUPTS_PWA0            = 45,
    INTERRUPTS_PWA1            = 46,
    INTERRUPTS_CPR             = 47,
    INTERRUPTS_SMI             = 48,
    INTERRUPTS_GPIO0           = 49,
    INTERRUPTS_GPIO1           = 50,
    INTERRUPTS_GPIO2           = 51,
    INTERRUPTS_GPIO3           = 52,
    INTERRUPTS_VC_I2C          = 53,
    INTERRUPTS_VC_SPI          = 54,
    INTERRUPTS_VC_I2SPCM       = 55,
    INTERRUPTS_VC_UART         = 57,
    INTERRUPTS_SHARED_END,

    INTERRUPTS_BASIC_BASE      = 64,
    INTERRUPTS_BASIC_ARM_TIMER_IRQ = INTERRUPTS_BASIC_BASE,
    INTERRUPTS_BASIC_ARM_MAILBOX_IRQ,
    INTERRUPTS_BASIC_ARM_DOORBELL_0_IRQ,
    INTERRUPTS_BASIC_GPU_0_HALTED_IRQ,
    INTERRUPTS_BASIC_GPU_1_HALTED_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_1_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_0_IRQ,
    INTERRUPTS_BASIC_END,
    INTERRUPTS_COUNT,
    INTERRUPTS_NONE = 255,
};



#endif
